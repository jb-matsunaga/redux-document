# Redux Document
Redux関連の英語ドキュメントor記事をGoogle翻訳で読んでいくログです。

[http://redux.js.org/][]

Reduxは、JavaScriptアプリの予測可能なコンテナです。

それは、一貫して動作し、異なる環境（クライアント、サーバー、およびネイティブ）で動作し、テストが容易なアプリケーションを作成するのに役立ちます。 さらに、リアルタイムのデバッガと組み合わせたライブコード編集など、優れた開発者エクスペリエンスを提供します。

ReduxをReactと一緒に使用することも、他のビューライブラリと併用することもできます。


## イントロダクション
### モチベーション
JavaScriptのシングルページアプリケーションの要件がますます複雑になるにつれて、私たちのコードはこれまで以上に多くの状態を管理する必要があります。 この状態には、サーバー応答とキャッシュされたデータ、およびサーバーにまだ永続化されていないローカルに作成されたデータが含まれます。 アクティブなルート、選択されたタブ、スピナー、ページネーションコントロールなどを管理する必要があるため、UIの状態も複雑になります。

この絶え間なく変化する状態を管理するのは難しいです。 あるモデルが別のモデルを更新できる場合、ビューはモデルを更新し、別のモデルを更新し、別のモデルが更新される可能性があります。 ある時点で、いつ、どうやってその状態を制御できなくなったとしても、アプリで何が起きるか理解できなくなります。 システムが不透明で非確定的な場合は、バグを再現したり、新しい機能を追加することは難しいです。

これが十分に悪くないかのように、フロントエンドの製品開発では新しい要件が一般的になります。 開発者としては、楽観的な更新、サーバー側のレンダリング、経路遷移を実行する前にデータを取得することなどが期待されます。 これまで対処していなかった複雑さを管理しようとしていることがわかりました。必然的に、あきらめる時が来ましたか？答えはノーです。

この複雑さは、人の心が推論するために非常に難しい2つのコンセプト、すなわち突然変異と非同期性を混合しているので、扱いにくいです。 私はそれらをMentosとCokeと呼んでいます。 どちらも分離で素晴らしいことができますが、一緒になって混乱を招きます。 Reactのようなライブラリは、非同期操作と直接的なDOM操作の両方を取り除いて、ビュー層でこの問題を解決しようとします。 しかし、データの状態を管理することはあなた次第です。 これはReduxが入る場所です。

Flux、CQRS、およびEvent Sourcingの手順に従って、Reduxは、どのように更新が行われるかについて一定の制限を課すことによって、状態の変異を予測可能にしようとします。 これらの制限は、Reduxの3つの原則に反映されています。

### コアコンセプト
Redux自体はとてもシンプルです。

あなたのアプリの状態が単純なオブジェクトとして記述されているとします。 たとえば、todoアプリの状態は次のようになります。

```javascript
{
  todos: [{
    text: 'Eat food',
    completed: true
  }, {
    text: 'Exercise',
    completed: false
  }],
  visibilityFilter: 'SHOW_COMPLETED'
}
```

このオブジェクトは、セッターがないことを除いて、 "モデル"のようなものです。 これは、コードのさまざまな部分が状態を任意に変更することができず、再現しにくいバグを引き起こすためです。

状態を変更するには、アクションをディスパッチする必要があります。 アクションとは、何が起こったのかを記述するプレーンなJavaScriptオブジェクト（どのような魔法を導入しないかに注意してください）です。 いくつかのアクションの例を次に示します。

```javascript
{ type: 'ADD_TODO', text: 'Go to swimming pool' }
{ type: 'TOGGLE_TODO', index: 1 }
{ type: 'SET_VISIBILITY_FILTER', filter: 'SHOW_ALL' }
```

すべての変更がアクションとして記述されていることを強制することで、アプリで何が起こっているのかを明確に理解できます。 変更されたものがあれば、その変更理由がわかります。 行動は、起こったことのブレッドクラムと同じです。 最後に、状態とアクションを結びつけるために、我々はReducerと呼ばれる関数を書く。 繰り返しになりますが、それについては何も魔法のようなものではありません。それは引数として状態とアクションを取り、関数の次の状態を返します。 大きなアプリではこのような関数を書くのは難しいので、状態の一部を管理する小さな関数を書く：

```javascript
function visibilityFilter(state = 'SHOW_ALL', action) {
  if (action.type === 'SET_VISIBILITY_FILTER') {
    return action.filter
  } else {
    return state
  }
}

function todos(state = [], action) {
  switch (action.type) {
    case 'ADD_TODO':
      return state.concat([{ text: action.text, completed: false }])
    case 'TOGGLE_TODO':
      return state.map(
        (todo, index) =>
          action.index === index
            ? { text: todo.text, completed: !todo.completed }
            : todo
      )
    default:
      return state
  }
}
```

そして、対応する状態キーのために2つのReducerを呼び出すことによって、アプリケーションの完全な状態を管理する別のReducerを書きます：

```javascript
function todoApp(state = {}, action) {
  return {
    todos: todos(state.todos, action),
    visibilityFilter: visibilityFilter(state.visibilityFilter, action)
  }
}
```

これは、基本的にReduxの考え方です。 Redux APIは使用していないことに注意してください。 このパターンを容易にするためのユーティリティがいくつかありますが、主な考え方は、アクションオブジェクトに応じて状態がどのように更新されるかを記述し、コードの90％がReduxを使用しない単純なJavaScriptです それ自体、そのAPI、または任意の魔法です。



